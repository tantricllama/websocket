var http = require('http'),
  crypto = require('crypto'),server
  events = require('events').EventEmitter,
  util = require('util'),
  connection = require('./connection.js'),
  connections = [];

// The module needs to allow for event listeners, so we need to extend the EventEmitter.
function server() {
  events.call(this);
}
util.inherits(server, events);

// Handler for the public listen method.
// Creates the HTTP server and applies the upgrade event listener.
server.prototype.listen = function(port) {
  http.createServer(handleRequest)
    .on('upgrade', upgradeHandler)
    .listen(port, function() {
      console.log('websocket server is listeing on http://localhost:%s', port);
    });
}

// Handler for the public write method.
// Encodes the message and writes it to all sockets.
server.prototype.write = function(message) {
  var bufferLength, bytes, i;

  // Calculate the buffer size
  if (message.length > 65535) {
    bufferLength = 10;
  } else if (message.length > 125) {
    bufferLength = 4;
  } else {
    bufferLength = 2;
  }

  bytes = new Buffer(bufferLength + message.length).fill(0);

  // Set the 'fin' bit (128 - true) and the 'opcode' bit (1 - test)
  bytes[0] += 128;
  bytes[0] += 1;

  // Add the 'length' bit.
  if (message.length > 65535) {
    bytes[1] += 127;
    bytes.writeUInt32BE(0, 2, true);
    bytes.writeUInt32BE(message.length, 6, true);
  } else if (message.length > 125) {
    bytes[1] += 126;
    bytes.writeUInt16BE(message.length, 2, true);
  } else {
    bytes[1] += message.length;
  }

  // Add the ascii values of the response message to the bytes array.
  for (i = 0; i < message.length; i++) {
    bytes.writeUInt8(message.charCodeAt(i), bufferLength + i);
  }

  for (i in connections) {
    connections[i].socket.write(bytes);
  }
}

module.exports = new server();


// HTTP request handler.
// Since we only need to handle the upgrade requests, everything else can 404.
function handleRequest(request, response) {
  response.writeHead(404, { 'Content-Type': 'text/plan' });
  response.end('404: File not found!');
}

// HTTP update handler.
// Accepts the handshake by responding to the upgrade request.
function upgradeHandler(request, socket) {
  // The Sec-WebSocket-Accept header is generated by concatenating the Sec-WebSocket-Key
  // sent by the client and "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" together, take
  // the SHA-1 hash of the result, and return the base64 encoding of the hash.
  var sha1 = crypto.createHash('sha1').update(request.headers['sec-websocket-key'] + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'),
    response = 'HTTP/1.1 101 Switching Protocols\r\n' +
      'Upgrade: websocket\r\n' +
      'Connection: Upgrade\r\n' +
      'Sec-WebSocket-Accept: ' + sha1.digest('base64') + '\r\n' +
      'Origin: ' + request.headers['origin'].replace(/[\r\n]/g, '') + '\r\n' +
      '\r\n',
    c = new connection(socket);

  c.on('frame', frameHandler);

  socket.write(response, 'ascii');
  connections.push(c);
}

// Handler for the connection's frame event.
// Emits text/binary frames.
function frameHandler(frame) {
  if (frame.opcode === 1) { // text
    module.exports.emit('text', frame.data.toString('ascii'));
  } else if (frame.opcode === 2) { // binary
    module.exports.emit('binary', frame.data.toString('binary'));
  } else {
    throw 'Invalid opcode [' + frame.opcode + ']';
  }
}